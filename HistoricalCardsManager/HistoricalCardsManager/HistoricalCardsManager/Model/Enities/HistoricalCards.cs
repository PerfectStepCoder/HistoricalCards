using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace HistoricalCardsManager.Model
{
    class HistoricalCards //: IObservable<T>
    {
        //IDisposable IObservable<T>.Subscribe(IObserver<T> observer)
        //{
        //    throw new NotImplementedException();
        //}
    }
}
        // Над методами которые выполняют долгую длительную работу обертывай в Task - патерн асинхонного вызова 4.5
        // Используй dynamic если работаешь с питоном или Excel

        // Пиши паттерн освобождения ресурсов Dispose Pattern (IDispose и using) реализация интерфеса IDisposable

        // TryStartNoGCRegion
        // во время работы кода (тут указатели) не будет работать GC
        // EndNoGCRegion

        // fixed - запрет сборщику мусора двигать указатель 

        // GC.keepAlive(мой объект) объект который не будет убран GC 
         
        // Используй атрибуты-аннотации
        //DllImportAttribute атрибут для взаимодействия с неуправляеммым кодом (библиотека на Си и С++)

        // ЛЮбой метод можно обернуть в делегад асинхронной работы уже сожержить BeginInvoke
        // Асинхронный вызов методов, вместо пулинга когда постоянно опрашиваем статус обработки чего либо
        // Поток чтения метод начинается с Begin и End

        // Используй event, см рекомендации для описание сигнатуры события, EventArg наследуйся от него и делае неизменяемым
        // Рассылка события
        // if (myEvent != null)
        //{
        //
        //}
        // События делай типа делегата Action
        // событие?.Invoke(this, message)
        // событие += лямбда выражение

        // лямбда

        /*
         * (int a, double b) =>{
         *     код
         *     return res;
         * }
         * 
         * int Cuda(double f) => реализация как лямбда выражение;
         */

         // Метод принимающий делегат (фильтр) и возвращающий коллекцию
         // Теперь можно методы перевадать в другие методы который ожидают соответствующий делегат

         //getCollection(Func<int, bool> filter)
         //{
         
         //}
         // Для работы с коллекциями ссмотри расширяющие методы
          
        // В делегат можно положить объектный или статический метод
        // В одной переменной делегата можно хранить несколько адресов функция
        // myDelegate.Invoke(params)
        // Готовые делегаты:
        // - не возвращает результат Acation<T>
        // - возвращает результат Func<T, T_result>
        // Анонимные методы

        // Интерфейс Сериализации для тонкой сериализации

        // Смотри слайды как работать с файлами 
        // - мутоды поиска в дереве каталога

        // избегай утечки ресурсов используй using

        // Можно так
        //int ch;
        //while ((ch = 7) == 7)
        //    {
        //    }

        // while((line = file.readline())!=)
        //{
        //}

        // try{   } finaly { освобождение ресурсов}

        // Используй сериализацию, можно указать какие поля не сериализовать

        // Пусть этот класс реализует интерфейс IEnumarable при этом по умолчании он будет возврпщать перечислитель в порядке добавления в колекцию карт
        // потом создавай метод GetSortByName и т.д с разными сортировками и порядками при этом используй yeild 

        // Автоматическое генерация Интерфейсов Перечисления
        //public IEnumarable GetReverseEnum()
        //{
        //    // Логика возврата элементов из коллекции (для циклов foreach)
        //    for (int i = 4; i >= 0; i--)
        //        yield return s[i];
        //}

        // Структура может реализовывать Интерфейс

        // Асбтранктый класс может наследовать Интерефейс

        // Делай сокрытие данных с помощью Интерфейсов
        // IMyInter s = star;

        // В интерфейсах может быть описаны события! и свойства! 

        // Наследование интерфейсов возможно

        // Контроль переполнения целочисленных операций checked {}
        // n = checked(n + 1); включить проверку для всего проекта

        // Реализовывай свои исключения не забывая про конструктор с inner исключением? которое вызвало данное исключение (стек трейс ошибки). Исключения деляе Serializable

        // int? count = Customers?.orders?.length;

        // Перевыбрасывай исключения throw до метода main

        // Используй информацию из Enviroment

        // Сделай запрет на права использовать рефлексию во время выполнения программы

        // Вложенные классы попробуй их!

        // Классы взаимодействуют друг с другом через интерфейсы и события а не через наследование 

        // Какие то классы будут sealed

        // Используй полиморфизм, но некоторые методы будут sealed overide т.е. с запретом дальнейшего переопределения     

        // Используй операторы is и as

        // От обычного класса можно наследоваться абстратным классом

        // В некторых классах можно затенить существующие методы в наследниках оператором new, переопределение за счет сокрытия

        // Используй полиморфные методы

        // Если переопределяешь equevls то и getHashcode переорпеделеи так что одинаковые сущности имеют одинаковый хеш-код
//        public HistoricalCards Select()
//        {
//            // Код фильтра коллекции
//            return this;
//        }
//    }
//}
